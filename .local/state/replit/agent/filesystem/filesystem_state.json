{"file_contents":{"replit.md":{"content":"# SM Furnishing Products API\n\n## Project Overview\nThis is a Node.js Express API backend for managing products and categories. It connects to MongoDB for data storage and provides REST endpoints for product operations.\n\n## Setup Status\n- âœ… Dependencies installed (Express, MongoDB, CORS, Nodemon)\n- âœ… Server configured for Replit environment (0.0.0.0:5000)\n- âœ… Workflow configured for development server\n- âœ… MongoDB connection established (6 products found)\n- âœ… API endpoints tested and working\n- âœ… Deployment configured for VM target\n\n## API Endpoints\n\n### Authentication\n- `POST /api/signup` - User registration (name, email, password) - Returns JWT token + user info\n- `POST /api/login` - User authentication (email, password) - Returns JWT token + user info\n- `POST /api/send-otp` - Send OTP to email for verification (email) - Returns success message\n- `POST /api/verify-otp` - Verify OTP code (email, otp) - Returns verification confirmation\n\n### Products\n- `GET /api/products` - Get all products\n- `POST /api/products` - Create new product\n- `GET /api/products/:id` - Get single product by ID\n- `DELETE /api/products/:id` - Delete product by ID\n\n### Categories\n- `GET /api/categories` - Get all categories\n- `POST /api/categories` - Create new category\n- `GET /api/categories/:id` - Get single category by ID\n- `DELETE /api/categories/:id` - Delete category by ID\n\n### System\n- `GET /` - API information and available endpoints\n- `GET /health` - Health check and database status\n\n## Required Environment Variables\n- `MONGODB_URI` - MongoDB connection string (needed to start server)\n- `JWT_SECRET` - JWT secret key for token generation (optional, has fallback)\n\n## Database Schema\n- Database: `smFurnishing`\n- Collections: `products`, `categories`, `users`, `otps`\n\n### Users Collection\n- Required fields: name, email, password\n- Email validation with regex pattern\n- Password minimum length: 6 characters\n- Unique index on email field\n- Additional fields: createdAt, updatedAt\n\n### Products Collection\n- Product fields: name, description, price, stock, categoryId, createdAt, updatedAt\n\n### Categories Collection  \n- Category fields: name, description, createdAt, updatedAt\n\n### OTPs Collection\n- OTP fields: email, otp, createdAt, verified, verifiedAt\n- TTL index: expires after 10 minutes (600 seconds)\n- Email service: Replit Mail integration\n\n## Recent Changes\n- 2025-09-19: Implemented email OTP verification system with send-otp and verify-otp endpoints\n- 2025-09-19: Added Replit Mail integration for sending OTP emails with HTML formatting\n- 2025-09-19: Created OTPs collection with TTL index for automatic expiration\n- 2025-09-19: Implemented JWT authentication system with signup and login endpoints\n- 2025-09-19: Added users collection with schema validation and unique email index\n- 2025-09-19: Added bcryptjs for password hashing and jsonwebtoken for JWT generation\n- 2025-09-19: Updated API documentation to include authentication endpoints\n- 2025-09-18: Configured server to bind to 0.0.0.0:5000 for Replit environment  \n- 2025-09-18: Set up development workflow with nodemon","size_bytes":3109},"server.js":{"content":"require('dotenv').config();\nconst express = require('express');\nconst { MongoClient, ObjectId } = require('mongodb');\nconst cors = require('cors');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst { sendEmail } = require('./utils/replitmail');\n\nconst app = express();\n\n// JWT Secret configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'sm-furnishing-jwt-secret-2024';\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// MongoDB connection\nconst uri = process.env.MONGODB_URI;\nconst client = new MongoClient(uri);\n\nlet db;\nlet productsCollection;\nlet categoriesCollection;\nlet usersCollection;\nlet otpCollection;\nlet latestproductsCollection;\n\n// Connect to MongoDB\nasync function connectToMongoDB() {\n  try {\n    await client.connect();\n    console.log('âœ… Connected to MongoDB Atlas');\n    \n    // Connect to the database and collections\n    db = client.db('smFurnishing');\n    productsCollection = db.collection('products');\n    categoriesCollection = db.collection('categories');\n    usersCollection = db.collection('users');\n    otpCollection = db.collection('otps');\n    latestproductsCollection = db.collection('latestproducts');\n    \n    // Create users collection with schema validation\n    try {\n      await db.createCollection(\"users\", {\n        validator: {\n          $jsonSchema: {\n            bsonType: \"object\",\n            required: [\"name\", \"email\", \"password\"],\n            properties: {\n              name: {\n                bsonType: \"string\",\n                description: \"must be a string and is required\"\n              },\n              email: {\n                bsonType: \"string\",\n                pattern: \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\",\n                description: \"must be a valid email and is required\"\n              },\n              password: {\n                bsonType: \"string\",\n                minLength: 6,\n                description: \"must be a string of at least 6 characters and is required\"\n              }\n            }\n          }\n        }\n      });\n      console.log('âœ… Users collection created with validation');\n    } catch (error) {\n      if (error.code === 48) {\n        console.log('â„¹ï¸ Users collection already exists');\n      } else {\n        console.log('âš ï¸ Error creating users collection:', error.message);\n      }\n    }\n    \n    // Create unique index for email\n    try {\n      await usersCollection.createIndex({ email: 1 }, { unique: true });\n      console.log('âœ… Unique index created for user emails');\n    } catch (error) {\n      console.log('â„¹ï¸ Email index already exists');\n    }\n    \n    // Create OTP collection with TTL index (expires after 10 minutes)\n    try {\n      await otpCollection.createIndex({ createdAt: 1 }, { expireAfterSeconds: 600 });\n      console.log('âœ… OTP collection configured with TTL index');\n    } catch (error) {\n      console.log('â„¹ï¸ OTP TTL index already exists');\n    }\n    \n    // Verify connection by counting documents\n    const count = await productsCollection.countDocuments();\n    const userCount = await usersCollection.countDocuments();\n    const otpCount = await otpCollection.countDocuments();\n    console.log(`ðŸ“¦ Found ${count} products in the database`);\n    console.log(`ðŸ‘¥ Found ${userCount} users in the database`);\n    console.log(`ðŸ“§ Found ${otpCount} active OTPs in the database`);\n    \n  } catch (error) {\n    console.error('âŒ MongoDB connection error:', error);\n    process.exit(1);\n  }\n}\n\n// POST /api/signup - User registration\napp.post('/api/signup', async (req, res) => {\n  try {\n    const { email, password, name } = req.body;\n    \n    // Validation\n    if (!email || !password || !name) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name, email, and password are required fields'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Validate password length\n    if (password.length < 6) {\n      return res.status(400).json({\n        success: false,\n        message: 'Password must be at least 6 characters long'\n      });\n    }\n    \n    // Check if email already exists\n    const existingUser = await usersCollection.findOne({ email: email.toLowerCase() });\n    if (existingUser) {\n      return res.status(400).json({\n        success: false,\n        message: 'User with this email already exists'\n      });\n    }\n    \n    // Encrypt password\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    \n    // Create new user object\n    const newUser = {\n      name: name.trim(),\n      email: email.toLowerCase().trim(),\n      password: hashedPassword,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Save user to database\n    const result = await usersCollection.insertOne(newUser);\n    \n    // Get the inserted user (without password)\n    const insertedUser = await usersCollection.findOne(\n      { _id: result.insertedId },\n      { projection: { password: 0 } }\n    );\n    \n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        userId: insertedUser._id,\n        email: insertedUser.email,\n        name: insertedUser.name\n      },\n      JWT_SECRET,\n      { expiresIn: '7d' }\n    );\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'User created successfully',\n      token: token,\n      user: insertedUser\n    });\n    \n    console.log(`âœ… New user registered: ${email}`);\n    \n  } catch (error) {\n    console.error('Error creating user:', error);\n    \n    // Handle duplicate email error\n    if (error.code === 11000) {\n      return res.status(400).json({\n        success: false,\n        message: 'User with this email already exists'\n      });\n    }\n    \n    res.status(500).json({\n      success: false,\n      message: 'Error creating user',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/login - User authentication\napp.post('/api/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Validation\n    if (!email || !password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email and password are required'\n      });\n    }\n    \n    // Find user by email\n    const user = await usersCollection.findOne({ email: email.toLowerCase() });\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Remove password from user object\n    const userWithoutPassword = {\n      _id: user._id,\n      name: user.name,\n      email: user.email,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt\n    };\n    \n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        userId: user._id,\n        email: user.email,\n        name: user.name\n      },\n      JWT_SECRET,\n      { expiresIn: '7d' }\n    );\n    \n    // Send success response\n    res.status(200).json({\n      success: true,\n      message: 'Login successful',\n      token: token,\n      user: userWithoutPassword\n    });\n    \n    console.log(`âœ… User logged in: ${email}`);\n    \n  } catch (error) {\n    console.error('Error during login:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error during login',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/send-otp - Send OTP to email\napp.post('/api/send-otp', async (req, res) => {\n  try {\n    const { email } = req.body;\n    \n    // Validation\n    if (!email) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email is required'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Generate 6-digit OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    \n    // Delete any existing OTPs for this email\n    await otpCollection.deleteMany({ email: email.toLowerCase() });\n    \n    // Store OTP in database\n    const otpRecord = {\n      email: email.toLowerCase(),\n      otp: otp,\n      createdAt: new Date(),\n      verified: false\n    };\n    \n    await otpCollection.insertOne(otpRecord);\n    \n    // Send OTP email\n    const emailResult = await sendEmail({\n      to: email,\n      subject: 'SM Furnishing - Email Verification Code',\n      text: `Your verification code is: ${otp}\\n\\nThis code will expire in 10 minutes.\\n\\nIf you didn't request this code, please ignore this email.`,\n      html: `\n        <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n          <h2 style=\"color: #333; text-align: center;\">Email Verification</h2>\n          <p>Your verification code is:</p>\n          <div style=\"text-align: center; margin: 30px 0;\">\n            <span style=\"font-size: 32px; font-weight: bold; background: #f0f0f0; padding: 15px 30px; border-radius: 5px; letter-spacing: 5px;\">${otp}</span>\n          </div>\n          <p style=\"color: #666;\">This code will expire in 10 minutes.</p>\n          <p style=\"color: #666; font-size: 12px;\">If you didn't request this code, please ignore this email.</p>\n        </div>\n      `\n    });\n    \n    console.log(`ðŸ“§ OTP sent to ${email}: ${otp}`);\n    \n    res.status(200).json({\n      success: true,\n      message: 'OTP sent successfully to your email',\n      email: email\n    });\n    \n  } catch (error) {\n    console.error('Error sending OTP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error sending OTP',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/verify-otp - Verify OTP\napp.post('/api/verify-otp', async (req, res) => {\n  try {\n    const { email, otp } = req.body;\n    \n    // Validation\n    if (!email || !otp) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email and OTP are required'\n      });\n    }\n    \n    // Find OTP record\n    const otpRecord = await otpCollection.findOne({\n      email: email.toLowerCase(),\n      otp: otp.toString(),\n      verified: false\n    });\n    \n    if (!otpRecord) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid or expired OTP'\n      });\n    }\n    \n    // Check if OTP is expired (10 minutes)\n    const now = new Date();\n    const otpAge = (now - otpRecord.createdAt) / 1000 / 60; // minutes\n    \n    if (otpAge > 10) {\n      // Clean up expired OTP\n      await otpCollection.deleteOne({ _id: otpRecord._id });\n      return res.status(400).json({\n        success: false,\n        message: 'OTP has expired. Please request a new one.'\n      });\n    }\n    \n    // Mark OTP as verified\n    await otpCollection.updateOne(\n      { _id: otpRecord._id },\n      { $set: { verified: true, verifiedAt: new Date() } }\n    );\n    \n    console.log(`âœ… OTP verified for ${email}`);\n    \n    res.status(200).json({\n      success: true,\n      message: 'Email verified successfully',\n      email: email,\n      verifiedAt: new Date()\n    });\n    \n  } catch (error) {\n    console.error('Error verifying OTP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error verifying OTP',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/products - Fetch all products\napp.get('/api/products', async (req, res) => {\n  try {\n    // Fetch all products from the collection\n    const products = await productsCollection.find({}).toArray();\n    \n    // Send successful response\n    res.status(200).json({\n      success: true,\n      count: products.length,\n      data: products\n    });\n    \n  } catch (error) {\n    console.error('Error fetching products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching products',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/products - Add a new product\napp.post('/api/products', async (req, res) => {\n  try {\n    const { categoryId, name, description, price, stock, status, imageUrl } = req.body;\n    \n    // Validation\n    if (!name || !description || !price) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name, description, and price are required fields'\n      });\n    }\n    \n    // Validate price is a positive number\n    if (typeof price !== 'number' || price <= 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Price must be a positive number'\n      });\n    }\n    \n    // Validate stock if provided\n    if (stock !== undefined && (typeof stock !== 'number' || stock < 0)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Stock must be a non-negative number'\n      });\n    }\n    \n    // If categoryId is provided, validate it exists (optional)\n    if (categoryId) {\n      try {\n        const categoryExists = await categoriesCollection.findOne({ \n          _id: new ObjectId(categoryId) \n        });\n        \n        if (!categoryExists) {\n          return res.status(400).json({\n            success: false,\n            message: 'Invalid category ID'\n          });\n        }\n      } catch (error) {\n        // If categoryId is not a valid ObjectId format\n        return res.status(400).json({\n          success: false,\n          message: 'Invalid category ID format'\n        });\n      }\n    }\n    \n    // Create new product object\n    const newProduct = {\n      categoryId: categoryId || null,\n      name: name.trim(),\n      description: description.trim(),\n      price: Number(price),\n      stock: stock !== undefined ? Number(stock) : 0,\n      status: status || \"Active\",\n      imageUrl: imageUrl || \"\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the product into database\n    const result = await productsCollection.insertOne(newProduct);\n    \n    // Get the inserted product\n    const insertedProduct = await productsCollection.findOne({ \n      _id: result.insertedId \n    });\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Product created successfully',\n      data: insertedProduct\n    });\n    \n    console.log(`âœ… New product added: ${name}`);\n    \n  } catch (error) {\n    console.error('Error creating product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error creating product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/products/:id - Get single product by ID\napp.get('/api/products/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid product ID format'\n      });\n    }\n    \n    const product = await productsCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: product\n    });\n    \n  } catch (error) {\n    console.error('Error fetching product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching product',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/products/:id - Delete a product\napp.delete('/api/products/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid product ID format'\n      });\n    }\n    \n    const result = await productsCollection.deleteOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (result.deletedCount === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Product deleted successfully'\n    });\n    \n    console.log(`ðŸ—‘ï¸ Product deleted: ${id}`);\n    \n  } catch (error) {\n    console.error('Error deleting product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error deleting product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/latestproducts - Fetch all latest products\napp.get('/api/latestproducts', async (req, res) => {\n  try {\n    // Fetch all latest products from the collection\n    const latestproducts = await latestproductsCollection.find({}).toArray();\n    \n    // Send successful response\n    res.status(200).json({\n      success: true,\n      count: latestproducts.length,\n      data: latestproducts\n    });\n    \n  } catch (error) {\n    console.error('Error fetching latest products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching latest products',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/latestproducts/:id - Get single latest product by ID\napp.get('/api/latestproducts/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid latest product ID format'\n      });\n    }\n    \n    const latestproduct = await latestproductsCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!latestproduct) {\n      return res.status(404).json({\n        success: false,\n        message: 'Latest product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: latestproduct\n    });\n    \n  } catch (error) {\n    console.error('Error fetching latest product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching latest product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/categories - Get all categories\napp.get('/api/categories', async (req, res) => {\n  try {\n    const categories = await categoriesCollection.find({}).toArray();\n    \n    res.status(200).json({\n      success: true,\n      count: categories.length,\n      data: categories\n    });\n    \n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching categories',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/categories - Add a new category\napp.post('/api/categories', async (req, res) => {\n  try {\n    const { name, description } = req.body;\n    \n    // Validation\n    if (!name) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name is required field'\n      });\n    }\n    \n    // Check if category name already exists\n    const existingCategory = await categoriesCollection.findOne({ \n      name: { $regex: new RegExp(`^${name.trim()}$`, 'i') }\n    });\n    \n    if (existingCategory) {\n      return res.status(400).json({\n        success: false,\n        message: 'Category with this name already exists'\n      });\n    }\n    \n    // Create new category object\n    const newCategory = {\n      name: name.trim(),\n      description: description ? description.trim() : \"\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the category into database\n    const result = await categoriesCollection.insertOne(newCategory);\n    \n    // Get the inserted category\n    const insertedCategory = await categoriesCollection.findOne({ \n      _id: result.insertedId \n    });\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Category created successfully',\n      data: insertedCategory\n    });\n    \n    console.log(`âœ… New category added: ${name}`);\n    \n  } catch (error) {\n    console.error('Error creating category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error creating category',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/categories/:id - Get single category by ID\napp.get('/api/categories/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid category ID format'\n      });\n    }\n    \n    const category = await categoriesCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!category) {\n      return res.status(404).json({\n        success: false,\n        message: 'Category not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: category\n    });\n    \n  } catch (error) {\n    console.error('Error fetching category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching category',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/categories/:id - Delete a category\napp.delete('/api/categories/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid category ID format'\n      });\n    }\n    \n    // Check if there are products using this category\n    const productsWithCategory = await productsCollection.countDocuments({ \n      categoryId: id \n    });\n    \n    if (productsWithCategory > 0) {\n      return res.status(400).json({\n        success: false,\n        message: `Cannot delete category. ${productsWithCategory} product(s) are using this category`\n      });\n    }\n    \n    const result = await categoriesCollection.deleteOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (result.deletedCount === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Category not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Category deleted successfully'\n    });\n    \n    console.log(`ðŸ—‘ï¸ Category deleted: ${id}`);\n    \n  } catch (error) {\n    console.error('Error deleting category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error deleting category',\n      error: error.message\n    });\n  }\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.status(200).json({ \n    status: 'OK',\n    message: 'Server is running',\n    database: db ? 'Connected' : 'Disconnected'\n  });\n});\n\n// Root endpoint\napp.get('/', (req, res) => {\n  res.json({ \n    message: 'SM Furnishing Products API',\n    endpoints: {\n      'POST /api/signup': 'User registration (name, email, password)',\n      'POST /api/login': 'User authentication (email, password)',\n      'POST /api/send-otp': 'Send OTP to email for verification (email)',\n      'POST /api/verify-otp': 'Verify OTP code (email, otp)',\n      'GET /api/products': 'Get all products',\n      'POST /api/products': 'Create new product',\n      'GET /api/products/:id': 'Get single product',\n      'DELETE /api/products/:id': 'Delete product',\n      'GET /api/latestproducts': 'Get all latest products',\n      'GET /api/latestproducts/:id': 'Get single latest product',\n      'GET /api/categories': 'Get all categories',\n      'POST /api/categories': 'Create new category',\n      'GET /api/categories/:id': 'Get single category',\n      'DELETE /api/categories/:id': 'Delete category',\n      'GET /health': 'Health check'\n    }\n  });\n});\n\n// Start server\nconst PORT = process.env.PORT || 3000;\n\nasync function startServer() {\n  await connectToMongoDB();\n  \n  app.listen(PORT, '0.0.0.0', () => {\n    console.log(`ðŸš€ Server is running on http://0.0.0.0:${PORT}`);\n    console.log(`ðŸ“ Products endpoint: http://0.0.0.0:${PORT}/api/products`);\n    console.log(`âž• Add product: POST http://0.0.0.0:${PORT}/api/products`);\n  });\n}\n\nstartServer();\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\nðŸ”„ Closing MongoDB connection...');\n  await client.close();\n  console.log('ðŸ‘‹ Server shutdown complete');\n  process.exit(0);\n});","size_bytes":24339},"utils/replitmail.js":{"content":"// Replit Mail utility for sending emails\n// Based on blueprint:replitmail\n\nfunction getAuthToken() {\n  const xReplitToken = process.env.REPL_IDENTITY\n    ? \"repl \" + process.env.REPL_IDENTITY\n    : process.env.WEB_REPL_RENEWAL\n      ? \"depl \" + process.env.WEB_REPL_RENEWAL\n      : null;\n\n  if (!xReplitToken) {\n    throw new Error(\n      \"No authentication token found. Please set REPL_IDENTITY or ensure you're running in Replit environment.\"\n    );\n  }\n\n  return xReplitToken;\n}\n\nasync function sendEmail(message) {\n  const authToken = getAuthToken();\n\n  const response = await fetch(\n    \"https://connectors.replit.com/api/v2/mailer/send\",\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X_REPLIT_TOKEN\": authToken,\n      },\n      body: JSON.stringify({\n        to: message.to,\n        cc: message.cc,\n        subject: message.subject,\n        text: message.text,\n        html: message.html,\n        attachments: message.attachments,\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to send email\");\n  }\n\n  return await response.json();\n}\n\nmodule.exports = { sendEmail };","size_bytes":1207}},"version":1}