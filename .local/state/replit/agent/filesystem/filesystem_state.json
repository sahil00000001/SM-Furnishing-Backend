{"file_contents":{"replit.md":{"content":"# SM Furnishing Products API\n\n## Project Overview\nThis is a Node.js Express API backend for managing products and categories. It connects to MongoDB for data storage and provides REST endpoints for product operations.\n\n## Setup Status\n- âœ… Dependencies installed (Express, MongoDB, CORS, Nodemon)\n- âœ… Server configured for Replit environment (0.0.0.0:5000)\n- âœ… Workflow configured for development server\n- âœ… MongoDB connection established (2 products found)\n- âœ… API endpoints tested and working\n- âœ… Deployment configured for VM target\n- âœ… GitHub import completed and project ready for use\n\n## API Endpoints\n\n### Authentication\n- `POST /api/signup` - User registration (name, email, password) - Returns JWT token + user info\n- `POST /api/login` - User authentication (email, password) - Returns JWT token + user info\n- `POST /api/send-otp` - Send OTP to email for verification (email) - Returns success message\n- `POST /api/verify-otp` - Verify OTP code (email, otp) - Returns verification confirmation\n\n### Products\n- `GET /api/products` - Get all products\n- `POST /api/products` - Create new product\n- `GET /api/products/:id` - Get single product by ID\n- `DELETE /api/products/:id` - Delete product by ID\n\n### Categories\n- `GET /api/categories` - Get all categories\n- `POST /api/categories` - Create new category\n- `GET /api/categories/:id` - Get single category by ID\n- `DELETE /api/categories/:id` - Delete category by ID\n\n### Cart Management (Requires JWT Authentication)\n- `GET /api/cart` - Get user's cart or create empty one if doesn't exist\n- `POST /api/cart/add` - Add item to cart (productId, quantity)\n- `PUT /api/cart/update` - Update item quantity (productId, quantity)\n- `DELETE /api/cart/item/:productId` - Remove single item from cart\n- `DELETE /api/cart/clear` - Clear entire cart\n\n### Form Data\n- `POST /api/form-data` - Store form submission (name, email, phoneNumber, orderDescription)\n\n### Newsletter\n- `POST /api/newsletter-emails` - Store email subscription (email)\n\n### System\n- `GET /` - API information and available endpoints\n- `GET /health` - Health check and database status\n\n## Required Environment Variables\n- `MONGODB_URI` - MongoDB connection string (needed to start server)\n- `JWT_SECRET` - JWT secret key for token generation (optional, has fallback)\n\n## Database Schema\n- Database: `smFurnishing`\n- Collections: `products`, `categories`, `users`, `otps`, `cart`, `form-data`, `newsletter-emails`\n\n### Users Collection\n- Required fields: name, email, password\n- Email validation with regex pattern\n- Password minimum length: 6 characters\n- Unique index on email field\n- Additional fields: createdAt, updatedAt\n\n### Products Collection\n- Product fields: name, description, price, stock, categoryId, createdAt, updatedAt\n\n### Categories Collection  \n- Category fields: name, description, createdAt, updatedAt\n\n### OTPs Collection\n- OTP fields: email, otp, createdAt, verified, verifiedAt\n- TTL index: expires after 10 minutes (600 seconds)\n- Email service: Replit Mail integration\n\n### Form-data Collection\n- Required fields: name, email, phoneNumber, orderDescription\n- Name validation: 2-100 characters\n- Email validation: regex pattern\n- Phone validation: international format with country code (e.g., +91-9876543210)\n- Order description: 10-10000 characters (supports large text)\n- Status field: new, contacted, in-progress, completed\n- Indexes: email+submittedAt, status, submittedAt\n- Additional fields: submittedAt, status, createdAt, updatedAt\n\n### Cart Collection\n- Required fields: userId, items, totalAmount, totalItems, status\n- userId: ObjectId reference to users collection\n- items: Array of cart items with productId, productName, productImage, quantity, priceAtTime, addedAt\n- totalAmount: Calculated total price of all items\n- totalItems: Calculated total quantity of all items\n- status: Enum values - active, abandoned, converted\n- Unique index on userId (one cart per user)\n- Indexes: userId (unique), items.productId, status, updatedAt\n- Additional fields: createdAt, updatedAt\n\n### Newsletter-emails Collection\n- Required fields: email\n- Email validation with regex pattern\n- Unique index on email field to prevent duplicates\n- Optional fields: subscribedAt, isActive, source\n- Source options: website, mobile, admin, import, campaign\n- Indexes: email (unique), subscribedAt, isActive\n- Additional fields: createdAt, updatedAt\n\n## Recent Changes\n- 2025-09-21: Implemented complete cart management system with 5 API endpoints and JWT authentication\n- 2025-09-21: Added cart collection with MongoDB schema validation and proper indexes\n- 2025-09-21: Created JWT authentication middleware for secure cart operations\n- 2025-09-21: Cart system includes stock validation, price-at-time storage, and automatic total calculations\n- 2025-09-21: Added comprehensive API documentation for all cart endpoints\n- 2025-09-21: Added form-data and newsletter-emails API endpoints with MongoDB collections\n- 2025-09-21: Implemented form submission API with validation for name, email, phone, and large order descriptions\n- 2025-09-21: Created newsletter subscription API with duplicate email prevention\n- 2025-09-21: Added MongoDB schema validation and performance indexes for new collections\n- 2025-09-21: Updated API documentation to include new endpoints\n- 2025-09-21: Completed GitHub import setup - all dependencies installed and verified working\n- 2025-09-21: Confirmed MongoDB Atlas connection and API endpoints functionality\n- 2025-09-21: Verified deployment configuration for VM target deployment\n- 2025-09-19: Implemented email OTP verification system with send-otp and verify-otp endpoints\n- 2025-09-19: Added Replit Mail integration for sending OTP emails with HTML formatting\n- 2025-09-19: Created OTPs collection with TTL index for automatic expiration\n- 2025-09-19: Implemented JWT authentication system with signup and login endpoints\n- 2025-09-19: Added users collection with schema validation and unique email index\n- 2025-09-19: Added bcryptjs for password hashing and jsonwebtoken for JWT generation\n- 2025-09-19: Updated API documentation to include authentication endpoints\n- 2025-09-18: Configured server to bind to 0.0.0.0:5000 for Replit environment  \n- 2025-09-18: Set up development workflow with nodemon","size_bytes":6280},"server.js":{"content":"require('dotenv').config();\nconst express = require('express');\nconst { MongoClient, ObjectId } = require('mongodb');\nconst cors = require('cors');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst { sendEmail } = require('./utils/replitmail');\n\nconst app = express();\n\n// JWT Secret configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'sm-furnishing-jwt-secret-2024';\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// JWT Authentication middleware\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Access denied. No token provided.',\n      error: 'Authentication required'\n    });\n  }\n\n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\n    if (err) {\n      return res.status(403).json({\n        success: false,\n        message: 'Invalid or expired token.',\n        error: 'Authentication failed'\n      });\n    }\n    req.user = decoded;\n    next();\n  });\n};\n\n// MongoDB connection\nconst uri = process.env.MONGODB_URI;\nconst client = new MongoClient(uri);\n\nlet db;\nlet productsCollection;\nlet categoriesCollection;\nlet usersCollection;\nlet otpCollection;\nlet latestproductsCollection;\nlet formDataCollection;\nlet newsletterEmailsCollection;\nlet cartCollection;\n\n// Connect to MongoDB\nasync function connectToMongoDB() {\n  try {\n    await client.connect();\n    console.log('âœ… Connected to MongoDB Atlas');\n    \n    // Connect to the database and collections\n    db = client.db('smFurnishing');\n    productsCollection = db.collection('products');\n    categoriesCollection = db.collection('categories');\n    usersCollection = db.collection('users');\n    otpCollection = db.collection('otps');\n    latestproductsCollection = db.collection('latestproducts');\n    formDataCollection = db.collection('form-data');\n    newsletterEmailsCollection = db.collection('newsletter-emails');\n    cartCollection = db.collection('cart');\n    \n    // Create users collection with schema validation\n    try {\n      await db.createCollection(\"users\", {\n        validator: {\n          $jsonSchema: {\n            bsonType: \"object\",\n            required: [\"name\", \"email\", \"password\"],\n            properties: {\n              name: {\n                bsonType: \"string\",\n                description: \"must be a string and is required\"\n              },\n              email: {\n                bsonType: \"string\",\n                pattern: \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\",\n                description: \"must be a valid email and is required\"\n              },\n              password: {\n                bsonType: \"string\",\n                minLength: 6,\n                description: \"must be a string of at least 6 characters and is required\"\n              }\n            }\n          }\n        }\n      });\n      console.log('âœ… Users collection created with validation');\n    } catch (error) {\n      if (error.code === 48) {\n        console.log('â„¹ï¸ Users collection already exists');\n      } else {\n        console.log('âš ï¸ Error creating users collection:', error.message);\n      }\n    }\n    \n    // Create unique index for email\n    try {\n      await usersCollection.createIndex({ email: 1 }, { unique: true });\n      console.log('âœ… Unique index created for user emails');\n    } catch (error) {\n      console.log('â„¹ï¸ Email index already exists');\n    }\n    \n    // Create OTP collection with TTL index (expires after 10 minutes)\n    try {\n      await otpCollection.createIndex({ createdAt: 1 }, { expireAfterSeconds: 600 });\n      console.log('âœ… OTP collection configured with TTL index');\n    } catch (error) {\n      console.log('â„¹ï¸ OTP TTL index already exists');\n    }\n    \n    // Create form-data collection with schema validation\n    try {\n      await db.createCollection(\"form-data\", {\n        validator: {\n          $jsonSchema: {\n            bsonType: \"object\",\n            required: [\"name\", \"email\", \"phoneNumber\", \"orderDescription\"],\n            properties: {\n              name: {\n                bsonType: \"string\",\n                minLength: 2,\n                maxLength: 100,\n                description: \"Name must be a string between 2 and 100 characters and is required\"\n              },\n              email: {\n                bsonType: \"string\",\n                pattern: \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\",\n                description: \"Must be a valid email address and is required\"\n              },\n              phoneNumber: {\n                bsonType: \"string\",\n                pattern: \"^\\\\+[1-9]\\\\d{0,3}[-\\\\.\\\\s]?\\\\(?\\\\d{1,4}\\\\)?[-\\\\.\\\\s]?\\\\d{1,4}[-\\\\.\\\\s]?\\\\d{1,9}$\",\n                description: \"Must be a valid international phone number with country code and is required\"\n              },\n              orderDescription: {\n                bsonType: \"string\",\n                minLength: 10,\n                maxLength: 10000,\n                description: \"Order description must be between 10 and 10000 characters and is required\"\n              },\n              submittedAt: {\n                bsonType: \"date\",\n                description: \"Submission timestamp\"\n              },\n              status: {\n                bsonType: \"string\",\n                enum: [\"new\", \"contacted\", \"in-progress\", \"completed\"],\n                description: \"Status must be one of the allowed values\"\n              },\n              createdAt: {\n                bsonType: \"date\",\n                description: \"Creation timestamp\"\n              },\n              updatedAt: {\n                bsonType: \"date\",\n                description: \"Last update timestamp\"\n              }\n            }\n          }\n        }\n      });\n      console.log('âœ… Form-data collection created with validation');\n    } catch (error) {\n      if (error.code === 48) {\n        console.log('â„¹ï¸ Form-data collection already exists');\n      } else {\n        console.log('âš ï¸ Error creating form-data collection:', error.message);\n      }\n    }\n    \n    // Create indexes for form-data collection\n    try {\n      await formDataCollection.createIndex({ email: 1, submittedAt: -1 });\n      await formDataCollection.createIndex({ status: 1 });\n      await formDataCollection.createIndex({ submittedAt: -1 });\n      console.log('âœ… Form-data indexes created');\n    } catch (error) {\n      console.log('â„¹ï¸ Form-data indexes already exist');\n    }\n    \n    // Create newsletter-emails collection with schema validation\n    try {\n      await db.createCollection(\"newsletter-emails\", {\n        validator: {\n          $jsonSchema: {\n            bsonType: \"object\",\n            required: [\"email\"],\n            properties: {\n              email: {\n                bsonType: \"string\",\n                pattern: \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\",\n                description: \"Must be a valid email address and is required\"\n              },\n              subscribedAt: {\n                bsonType: \"date\",\n                description: \"Subscription timestamp\"\n              },\n              isActive: {\n                bsonType: \"bool\",\n                description: \"Subscription status\"\n              },\n              source: {\n                bsonType: \"string\",\n                enum: [\"website\", \"mobile\", \"admin\", \"import\", \"campaign\"],\n                description: \"Source of subscription\"\n              },\n              createdAt: {\n                bsonType: \"date\",\n                description: \"Creation timestamp\"\n              },\n              updatedAt: {\n                bsonType: \"date\",\n                description: \"Last update timestamp\"\n              }\n            }\n          }\n        }\n      });\n      console.log('âœ… Newsletter-emails collection created with validation');\n    } catch (error) {\n      if (error.code === 48) {\n        console.log('â„¹ï¸ Newsletter-emails collection already exists');\n      } else {\n        console.log('âš ï¸ Error creating newsletter-emails collection:', error.message);\n      }\n    }\n    \n    // Create indexes for newsletter-emails collection\n    try {\n      await newsletterEmailsCollection.createIndex({ email: 1 }, { unique: true });\n      await newsletterEmailsCollection.createIndex({ subscribedAt: -1 });\n      await newsletterEmailsCollection.createIndex({ isActive: 1 });\n      console.log('âœ… Newsletter-emails indexes created');\n    } catch (error) {\n      console.log('â„¹ï¸ Newsletter-emails indexes already exist');\n    }\n    \n    // Create cart collection with schema validation\n    try {\n      await db.createCollection(\"cart\", {\n        validator: {\n          $jsonSchema: {\n            bsonType: \"object\",\n            required: [\"userId\", \"items\", \"totalAmount\", \"totalItems\", \"status\"],\n            properties: {\n              userId: {\n                bsonType: \"objectId\",\n                description: \"must be an ObjectId and is required\"\n              },\n              items: {\n                bsonType: \"array\",\n                description: \"must be an array of cart items\",\n                items: {\n                  bsonType: \"object\",\n                  required: [\"productId\", \"productName\", \"productImage\", \"quantity\", \"priceAtTime\", \"addedAt\"],\n                  properties: {\n                    productId: {\n                      bsonType: \"objectId\",\n                      description: \"must be an ObjectId and is required\"\n                    },\n                    productName: {\n                      bsonType: \"string\",\n                      description: \"must be a string and is required\"\n                    },\n                    productImage: {\n                      bsonType: \"string\",\n                      description: \"must be a string and is required\"\n                    },\n                    quantity: {\n                      bsonType: \"int\",\n                      minimum: 1,\n                      description: \"must be an integer >= 1 and is required\"\n                    },\n                    priceAtTime: {\n                      bsonType: \"number\",\n                      minimum: 0,\n                      description: \"must be a number >= 0 and is required\"\n                    },\n                    addedAt: {\n                      bsonType: \"date\",\n                      description: \"must be a date and is required\"\n                    }\n                  }\n                }\n              },\n              totalAmount: {\n                bsonType: \"number\",\n                minimum: 0,\n                description: \"must be a number >= 0 and is required\"\n              },\n              totalItems: {\n                bsonType: \"int\",\n                minimum: 0,\n                description: \"must be an integer >= 0 and is required\"\n              },\n              createdAt: {\n                bsonType: \"date\",\n                description: \"must be a date\"\n              },\n              updatedAt: {\n                bsonType: \"date\",\n                description: \"must be a date\"\n              },\n              status: {\n                bsonType: \"string\",\n                enum: [\"active\", \"abandoned\", \"converted\"],\n                description: \"must be one of: active, abandoned, converted and is required\"\n              }\n            }\n          }\n        }\n      });\n      console.log('âœ… Cart collection created with validation');\n    } catch (error) {\n      if (error.code === 48) {\n        console.log('â„¹ï¸ Cart collection already exists');\n      } else {\n        console.log('âš ï¸ Error creating cart collection:', error.message);\n      }\n    }\n    \n    // Create indexes for cart collection\n    try {\n      await cartCollection.createIndex({ userId: 1 }, { unique: true });\n      await cartCollection.createIndex({ \"items.productId\": 1 });\n      await cartCollection.createIndex({ status: 1 });\n      await cartCollection.createIndex({ updatedAt: -1 });\n      console.log('âœ… Cart collection indexes created');\n    } catch (error) {\n      console.log('â„¹ï¸ Cart collection indexes already exist');\n    }\n    \n    // Verify connection by counting documents\n    const count = await productsCollection.countDocuments();\n    const userCount = await usersCollection.countDocuments();\n    const otpCount = await otpCollection.countDocuments();\n    console.log(`ðŸ“¦ Found ${count} products in the database`);\n    console.log(`ðŸ‘¥ Found ${userCount} users in the database`);\n    console.log(`ðŸ“§ Found ${otpCount} active OTPs in the database`);\n    \n  } catch (error) {\n    console.error('âŒ MongoDB connection error:', error);\n    process.exit(1);\n  }\n}\n\n// POST /api/signup - User registration\napp.post('/api/signup', async (req, res) => {\n  try {\n    const { email, password, name } = req.body;\n    \n    // Validation\n    if (!email || !password || !name) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name, email, and password are required fields'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Validate password length\n    if (password.length < 6) {\n      return res.status(400).json({\n        success: false,\n        message: 'Password must be at least 6 characters long'\n      });\n    }\n    \n    // Check if email already exists\n    const existingUser = await usersCollection.findOne({ email: email.toLowerCase() });\n    if (existingUser) {\n      return res.status(400).json({\n        success: false,\n        message: 'User with this email already exists'\n      });\n    }\n    \n    // Encrypt password\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    \n    // Create new user object\n    const newUser = {\n      name: name.trim(),\n      email: email.toLowerCase().trim(),\n      password: hashedPassword,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Save user to database\n    const result = await usersCollection.insertOne(newUser);\n    \n    // Get the inserted user (without password)\n    const insertedUser = await usersCollection.findOne(\n      { _id: result.insertedId },\n      { projection: { password: 0 } }\n    );\n    \n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        userId: insertedUser._id,\n        email: insertedUser.email,\n        name: insertedUser.name\n      },\n      JWT_SECRET,\n      { expiresIn: '7d' }\n    );\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'User created successfully',\n      token: token,\n      user: insertedUser\n    });\n    \n    console.log(`âœ… New user registered: ${email}`);\n    \n  } catch (error) {\n    console.error('Error creating user:', error);\n    \n    // Handle duplicate email error\n    if (error.code === 11000) {\n      return res.status(400).json({\n        success: false,\n        message: 'User with this email already exists'\n      });\n    }\n    \n    res.status(500).json({\n      success: false,\n      message: 'Error creating user',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/login - User authentication\napp.post('/api/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Validation\n    if (!email || !password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email and password are required'\n      });\n    }\n    \n    // Find user by email\n    const user = await usersCollection.findOne({ email: email.toLowerCase() });\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Remove password from user object\n    const userWithoutPassword = {\n      _id: user._id,\n      name: user.name,\n      email: user.email,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt\n    };\n    \n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        userId: user._id,\n        email: user.email,\n        name: user.name\n      },\n      JWT_SECRET,\n      { expiresIn: '7d' }\n    );\n    \n    // Send success response\n    res.status(200).json({\n      success: true,\n      message: 'Login successful',\n      token: token,\n      user: userWithoutPassword\n    });\n    \n    console.log(`âœ… User logged in: ${email}`);\n    \n  } catch (error) {\n    console.error('Error during login:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error during login',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/send-otp - Send OTP to email\napp.post('/api/send-otp', async (req, res) => {\n  try {\n    const { email } = req.body;\n    \n    // Validation\n    if (!email) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email is required'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Generate 6-digit OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    \n    // Delete any existing OTPs for this email\n    await otpCollection.deleteMany({ email: email.toLowerCase() });\n    \n    // Store OTP in database\n    const otpRecord = {\n      email: email.toLowerCase(),\n      otp: otp,\n      createdAt: new Date(),\n      verified: false\n    };\n    \n    await otpCollection.insertOne(otpRecord);\n    \n    // Send OTP email\n    const emailResult = await sendEmail({\n      to: email,\n      subject: 'SM Furnishing - Email Verification Code',\n      text: `Your verification code is: ${otp}\\n\\nThis code will expire in 10 minutes.\\n\\nIf you didn't request this code, please ignore this email.`,\n      html: `\n        <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n          <h2 style=\"color: #333; text-align: center;\">Email Verification</h2>\n          <p>Your verification code is:</p>\n          <div style=\"text-align: center; margin: 30px 0;\">\n            <span style=\"font-size: 32px; font-weight: bold; background: #f0f0f0; padding: 15px 30px; border-radius: 5px; letter-spacing: 5px;\">${otp}</span>\n          </div>\n          <p style=\"color: #666;\">This code will expire in 10 minutes.</p>\n          <p style=\"color: #666; font-size: 12px;\">If you didn't request this code, please ignore this email.</p>\n        </div>\n      `\n    });\n    \n    console.log(`ðŸ“§ OTP sent to ${email}: ${otp}`);\n    \n    res.status(200).json({\n      success: true,\n      message: 'OTP sent successfully to your email',\n      email: email\n    });\n    \n  } catch (error) {\n    console.error('Error sending OTP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error sending OTP',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/verify-otp - Verify OTP\napp.post('/api/verify-otp', async (req, res) => {\n  try {\n    const { email, otp } = req.body;\n    \n    // Validation\n    if (!email || !otp) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email and OTP are required'\n      });\n    }\n    \n    // Find OTP record\n    const otpRecord = await otpCollection.findOne({\n      email: email.toLowerCase(),\n      otp: otp.toString(),\n      verified: false\n    });\n    \n    if (!otpRecord) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid or expired OTP'\n      });\n    }\n    \n    // Check if OTP is expired (10 minutes)\n    const now = new Date();\n    const otpAge = (now - otpRecord.createdAt) / 1000 / 60; // minutes\n    \n    if (otpAge > 10) {\n      // Clean up expired OTP\n      await otpCollection.deleteOne({ _id: otpRecord._id });\n      return res.status(400).json({\n        success: false,\n        message: 'OTP has expired. Please request a new one.'\n      });\n    }\n    \n    // Mark OTP as verified\n    await otpCollection.updateOne(\n      { _id: otpRecord._id },\n      { $set: { verified: true, verifiedAt: new Date() } }\n    );\n    \n    console.log(`âœ… OTP verified for ${email}`);\n    \n    res.status(200).json({\n      success: true,\n      message: 'Email verified successfully',\n      email: email,\n      verifiedAt: new Date()\n    });\n    \n  } catch (error) {\n    console.error('Error verifying OTP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error verifying OTP',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/products - Fetch all products\napp.get('/api/products', async (req, res) => {\n  try {\n    // Fetch all products from the collection\n    const products = await productsCollection.find({}).toArray();\n    \n    // Send successful response\n    res.status(200).json({\n      success: true,\n      count: products.length,\n      data: products\n    });\n    \n  } catch (error) {\n    console.error('Error fetching products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching products',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/products - Add a new product\napp.post('/api/products', async (req, res) => {\n  try {\n    const { categoryId, name, description, price, stock, status, imageUrl } = req.body;\n    \n    // Validation\n    if (!name || !description || !price) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name, description, and price are required fields'\n      });\n    }\n    \n    // Validate price is a positive number\n    if (typeof price !== 'number' || price <= 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Price must be a positive number'\n      });\n    }\n    \n    // Validate stock if provided\n    if (stock !== undefined && (typeof stock !== 'number' || stock < 0)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Stock must be a non-negative number'\n      });\n    }\n    \n    // If categoryId is provided, validate it exists (optional)\n    if (categoryId) {\n      try {\n        const categoryExists = await categoriesCollection.findOne({ \n          _id: new ObjectId(categoryId) \n        });\n        \n        if (!categoryExists) {\n          return res.status(400).json({\n            success: false,\n            message: 'Invalid category ID'\n          });\n        }\n      } catch (error) {\n        // If categoryId is not a valid ObjectId format\n        return res.status(400).json({\n          success: false,\n          message: 'Invalid category ID format'\n        });\n      }\n    }\n    \n    // Create new product object\n    const newProduct = {\n      categoryId: categoryId || null,\n      name: name.trim(),\n      description: description.trim(),\n      price: Number(price),\n      stock: stock !== undefined ? Number(stock) : 0,\n      status: status || \"Active\",\n      imageUrl: imageUrl || \"\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the product into database\n    const result = await productsCollection.insertOne(newProduct);\n    \n    // Get the inserted product\n    const insertedProduct = await productsCollection.findOne({ \n      _id: result.insertedId \n    });\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Product created successfully',\n      data: insertedProduct\n    });\n    \n    console.log(`âœ… New product added: ${name}`);\n    \n  } catch (error) {\n    console.error('Error creating product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error creating product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/products/:id - Get single product by ID\napp.get('/api/products/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid product ID format'\n      });\n    }\n    \n    const product = await productsCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: product\n    });\n    \n  } catch (error) {\n    console.error('Error fetching product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching product',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/products/:id - Delete a product\napp.delete('/api/products/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid product ID format'\n      });\n    }\n    \n    const result = await productsCollection.deleteOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (result.deletedCount === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Product deleted successfully'\n    });\n    \n    console.log(`ðŸ—‘ï¸ Product deleted: ${id}`);\n    \n  } catch (error) {\n    console.error('Error deleting product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error deleting product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/latestproducts - Fetch all latest products\napp.get('/api/latestproducts', async (req, res) => {\n  try {\n    // Fetch all latest products from the collection\n    const latestproducts = await latestproductsCollection.find({}).toArray();\n    \n    // Send successful response\n    res.status(200).json({\n      success: true,\n      count: latestproducts.length,\n      data: latestproducts\n    });\n    \n  } catch (error) {\n    console.error('Error fetching latest products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching latest products',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/latestproducts/:id - Get single latest product by ID\napp.get('/api/latestproducts/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid latest product ID format'\n      });\n    }\n    \n    const latestproduct = await latestproductsCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!latestproduct) {\n      return res.status(404).json({\n        success: false,\n        message: 'Latest product not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: latestproduct\n    });\n    \n  } catch (error) {\n    console.error('Error fetching latest product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching latest product',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/categories - Get all categories\napp.get('/api/categories', async (req, res) => {\n  try {\n    const categories = await categoriesCollection.find({}).toArray();\n    \n    res.status(200).json({\n      success: true,\n      count: categories.length,\n      data: categories\n    });\n    \n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching categories',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/categories - Add a new category\napp.post('/api/categories', async (req, res) => {\n  try {\n    const { name, description } = req.body;\n    \n    // Validation\n    if (!name) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name is required field'\n      });\n    }\n    \n    // Check if category name already exists\n    const existingCategory = await categoriesCollection.findOne({ \n      name: { $regex: new RegExp(`^${name.trim()}$`, 'i') }\n    });\n    \n    if (existingCategory) {\n      return res.status(400).json({\n        success: false,\n        message: 'Category with this name already exists'\n      });\n    }\n    \n    // Create new category object\n    const newCategory = {\n      name: name.trim(),\n      description: description ? description.trim() : \"\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the category into database\n    const result = await categoriesCollection.insertOne(newCategory);\n    \n    // Get the inserted category\n    const insertedCategory = await categoriesCollection.findOne({ \n      _id: result.insertedId \n    });\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Category created successfully',\n      data: insertedCategory\n    });\n    \n    console.log(`âœ… New category added: ${name}`);\n    \n  } catch (error) {\n    console.error('Error creating category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error creating category',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/categories/:id - Get single category by ID\napp.get('/api/categories/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid category ID format'\n      });\n    }\n    \n    const category = await categoriesCollection.findOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (!category) {\n      return res.status(404).json({\n        success: false,\n        message: 'Category not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      data: category\n    });\n    \n  } catch (error) {\n    console.error('Error fetching category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching category',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/categories/:id - Delete a category\napp.delete('/api/categories/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Validate ID format\n    if (!ObjectId.isValid(id)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid category ID format'\n      });\n    }\n    \n    // Check if there are products using this category\n    const productsWithCategory = await productsCollection.countDocuments({ \n      categoryId: id \n    });\n    \n    if (productsWithCategory > 0) {\n      return res.status(400).json({\n        success: false,\n        message: `Cannot delete category. ${productsWithCategory} product(s) are using this category`\n      });\n    }\n    \n    const result = await categoriesCollection.deleteOne({ \n      _id: new ObjectId(id) \n    });\n    \n    if (result.deletedCount === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Category not found'\n      });\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Category deleted successfully'\n    });\n    \n    console.log(`ðŸ—‘ï¸ Category deleted: ${id}`);\n    \n  } catch (error) {\n    console.error('Error deleting category:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error deleting category',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/form-data - Store form submission\napp.post('/api/form-data', async (req, res) => {\n  try {\n    const { name, email, phoneNumber, orderDescription } = req.body;\n    \n    // Validation\n    if (!name || !email || !phoneNumber || !orderDescription) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name, email, phone number, and order description are required fields'\n      });\n    }\n    \n    // Validate name length\n    if (name.length < 2 || name.length > 100) {\n      return res.status(400).json({\n        success: false,\n        message: 'Name must be between 2 and 100 characters'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Validate phone number format\n    const phoneRegex = /^\\+[1-9]\\d{0,3}[-.\\s]?\\(?\\d{1,4}\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}$/;\n    if (!phoneRegex.test(phoneNumber)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid international phone number with country code (e.g., +91-9876543210)'\n      });\n    }\n    \n    // Validate order description length\n    if (orderDescription.length < 10 || orderDescription.length > 10000) {\n      return res.status(400).json({\n        success: false,\n        message: 'Order description must be between 10 and 10000 characters'\n      });\n    }\n    \n    // Create new form submission object\n    const newFormData = {\n      name: name.trim(),\n      email: email.toLowerCase().trim(),\n      phoneNumber: phoneNumber.trim(),\n      orderDescription: orderDescription.trim(),\n      submittedAt: new Date(),\n      status: \"new\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the form data into database\n    const result = await formDataCollection.insertOne(newFormData);\n    \n    // Get the inserted form data\n    const insertedFormData = await formDataCollection.findOne({ \n      _id: result.insertedId \n    });\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Form data submitted successfully',\n      data: insertedFormData\n    });\n    \n    console.log(`âœ… New form submission from: ${email}`);\n    \n  } catch (error) {\n    console.error('Error storing form data:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error storing form data',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/newsletter-emails - Store email subscription\napp.post('/api/newsletter-emails', async (req, res) => {\n  try {\n    const { email } = req.body;\n    \n    // Validation\n    if (!email) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email address is required'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Please enter a valid email address'\n      });\n    }\n    \n    // Check if email already exists\n    const existingEmail = await newsletterEmailsCollection.findOne({ \n      email: email.toLowerCase() \n    });\n    \n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'This email address is already subscribed to our newsletter'\n      });\n    }\n    \n    // Create new email subscription object\n    const newEmailSubscription = {\n      email: email.toLowerCase().trim(),\n      subscribedAt: new Date(),\n      isActive: true,\n      source: \"website\",\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    // Insert the email subscription into database\n    const result = await newsletterEmailsCollection.insertOne(newEmailSubscription);\n    \n    // Send success response\n    res.status(201).json({\n      success: true,\n      message: 'Email address has been added successfully'\n    });\n    \n    console.log(`âœ… New newsletter subscription: ${email}`);\n    \n  } catch (error) {\n    console.error('Error storing newsletter email:', error);\n    \n    // Handle duplicate email error from unique index\n    if (error.code === 11000) {\n      return res.status(400).json({\n        success: false,\n        message: 'This email address is already subscribed to our newsletter'\n      });\n    }\n    \n    res.status(500).json({\n      success: false,\n      message: 'Error storing email address',\n      error: error.message\n    });\n  }\n});\n\n// ===========================================\n// CART API ENDPOINTS\n// ===========================================\n\n// GET /api/cart - Get user's cart\napp.get('/api/cart', authenticateToken, async (req, res) => {\n  try {\n    const userId = new ObjectId(req.user.userId);\n    \n    // Find user's cart\n    let cart = await cartCollection.findOne({ userId, status: 'active' });\n    \n    // If no cart exists, create an empty one\n    if (!cart) {\n      cart = {\n        userId,\n        items: [],\n        totalAmount: 0,\n        totalItems: 0,\n        status: 'active',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n      \n      const result = await cartCollection.insertOne(cart);\n      cart._id = result.insertedId;\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Cart retrieved successfully',\n      cart: cart\n    });\n    \n  } catch (error) {\n    console.error('Error getting cart:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error retrieving cart',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/cart/add - Add item to cart\napp.post('/api/cart/add', authenticateToken, async (req, res) => {\n  try {\n    const { productId, quantity } = req.body;\n    const userId = new ObjectId(req.user.userId);\n    \n    // Validation\n    if (!productId || !quantity) {\n      return res.status(400).json({\n        success: false,\n        message: 'Product ID and quantity are required',\n        error: 'Missing required fields'\n      });\n    }\n    \n    if (quantity <= 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Quantity must be greater than 0',\n        error: 'Invalid quantity'\n      });\n    }\n    \n    // Check if product exists\n    const product = await productsCollection.findOne({ _id: new ObjectId(productId) });\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Product not found',\n        error: 'Product does not exist'\n      });\n    }\n    \n    // Check stock availability\n    if (product.stock < quantity) {\n      return res.status(400).json({\n        success: false,\n        message: `Only ${product.stock} items available in stock`,\n        error: 'Insufficient stock'\n      });\n    }\n    \n    // Find or create cart\n    let cart = await cartCollection.findOne({ userId, status: 'active' });\n    \n    if (!cart) {\n      // Create new cart\n      cart = {\n        userId,\n        items: [],\n        totalAmount: 0,\n        totalItems: 0,\n        status: 'active',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n    }\n    \n    // Check if item already exists in cart\n    const existingItemIndex = cart.items.findIndex(item => \n      item.productId.toString() === productId\n    );\n    \n    if (existingItemIndex >= 0) {\n      // Update existing item quantity\n      const newQuantity = cart.items[existingItemIndex].quantity + quantity;\n      \n      // Check total stock for updated quantity\n      if (product.stock < newQuantity) {\n        return res.status(400).json({\n          success: false,\n          message: `Cannot add ${quantity} items. Only ${product.stock - cart.items[existingItemIndex].quantity} more available`,\n          error: 'Insufficient stock for total quantity'\n        });\n      }\n      \n      cart.items[existingItemIndex].quantity = newQuantity;\n      cart.items[existingItemIndex].addedAt = new Date();\n    } else {\n      // Add new item to cart\n      const cartItem = {\n        productId: new ObjectId(productId),\n        productName: product.name,\n        productImage: product.imageUrl || '',\n        quantity: quantity,\n        priceAtTime: product.price,\n        addedAt: new Date()\n      };\n      cart.items.push(cartItem);\n    }\n    \n    // Recalculate totals\n    cart.totalAmount = cart.items.reduce((total, item) => \n      total + (item.priceAtTime * item.quantity), 0\n    );\n    cart.totalItems = cart.items.reduce((total, item) => \n      total + item.quantity, 0\n    );\n    cart.updatedAt = new Date();\n    \n    // Save cart\n    if (cart._id) {\n      await cartCollection.replaceOne({ _id: cart._id }, cart);\n    } else {\n      const result = await cartCollection.insertOne(cart);\n      cart._id = result.insertedId;\n    }\n    \n    res.status(200).json({\n      success: true,\n      message: 'Item added to cart successfully',\n      cart: cart\n    });\n    \n    console.log(`âœ… Item added to cart - User: ${req.user.email}, Product: ${product.name}`);\n    \n  } catch (error) {\n    console.error('Error adding item to cart:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error adding item to cart',\n      error: error.message\n    });\n  }\n});\n\n// PUT /api/cart/update - Update item quantity\napp.put('/api/cart/update', authenticateToken, async (req, res) => {\n  try {\n    const { productId, quantity } = req.body;\n    const userId = new ObjectId(req.user.userId);\n    \n    // Validation\n    if (!productId || quantity === undefined) {\n      return res.status(400).json({\n        success: false,\n        message: 'Product ID and quantity are required',\n        error: 'Missing required fields'\n      });\n    }\n    \n    if (quantity < 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Quantity cannot be negative',\n        error: 'Invalid quantity'\n      });\n    }\n    \n    // Find cart\n    const cart = await cartCollection.findOne({ userId, status: 'active' });\n    if (!cart) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cart not found',\n        error: 'No active cart exists'\n      });\n    }\n    \n    // Find item in cart\n    const itemIndex = cart.items.findIndex(item => \n      item.productId.toString() === productId\n    );\n    \n    if (itemIndex === -1) {\n      return res.status(404).json({\n        success: false,\n        message: 'Item not found in cart',\n        error: 'Product not in cart'\n      });\n    }\n    \n    // Check stock if quantity > 0\n    if (quantity > 0) {\n      const product = await productsCollection.findOne({ _id: new ObjectId(productId) });\n      if (!product) {\n        return res.status(404).json({\n          success: false,\n          message: 'Product not found',\n          error: 'Product does not exist'\n        });\n      }\n      \n      if (product.stock < quantity) {\n        return res.status(400).json({\n          success: false,\n          message: `Only ${product.stock} items available in stock`,\n          error: 'Insufficient stock'\n        });\n      }\n    }\n    \n    // Update quantity or remove item\n    if (quantity === 0) {\n      cart.items.splice(itemIndex, 1);\n    } else {\n      cart.items[itemIndex].quantity = quantity;\n      cart.items[itemIndex].addedAt = new Date();\n    }\n    \n    // Recalculate totals\n    cart.totalAmount = cart.items.reduce((total, item) => \n      total + (item.priceAtTime * item.quantity), 0\n    );\n    cart.totalItems = cart.items.reduce((total, item) => \n      total + item.quantity, 0\n    );\n    cart.updatedAt = new Date();\n    \n    // Save cart\n    await cartCollection.replaceOne({ _id: cart._id }, cart);\n    \n    res.status(200).json({\n      success: true,\n      message: quantity === 0 ? 'Item removed from cart' : 'Cart updated successfully',\n      cart: cart\n    });\n    \n    console.log(`âœ… Cart updated - User: ${req.user.email}, Product: ${productId}, Quantity: ${quantity}`);\n    \n  } catch (error) {\n    console.error('Error updating cart:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error updating cart',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/cart/item/:productId - Remove single item\napp.delete('/api/cart/item/:productId', authenticateToken, async (req, res) => {\n  try {\n    const { productId } = req.params;\n    const userId = new ObjectId(req.user.userId);\n    \n    // Validation\n    if (!ObjectId.isValid(productId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid product ID format',\n        error: 'Invalid ObjectId'\n      });\n    }\n    \n    // Find cart\n    const cart = await cartCollection.findOne({ userId, status: 'active' });\n    if (!cart) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cart not found',\n        error: 'No active cart exists'\n      });\n    }\n    \n    // Find item in cart\n    const itemIndex = cart.items.findIndex(item => \n      item.productId.toString() === productId\n    );\n    \n    if (itemIndex === -1) {\n      return res.status(404).json({\n        success: false,\n        message: 'Item not found in cart',\n        error: 'Product not in cart'\n      });\n    }\n    \n    // Remove item\n    const removedItem = cart.items[itemIndex];\n    cart.items.splice(itemIndex, 1);\n    \n    // Recalculate totals\n    cart.totalAmount = cart.items.reduce((total, item) => \n      total + (item.priceAtTime * item.quantity), 0\n    );\n    cart.totalItems = cart.items.reduce((total, item) => \n      total + item.quantity, 0\n    );\n    cart.updatedAt = new Date();\n    \n    // Save cart\n    await cartCollection.replaceOne({ _id: cart._id }, cart);\n    \n    res.status(200).json({\n      success: true,\n      message: 'Item removed from cart successfully',\n      cart: cart\n    });\n    \n    console.log(`âœ… Item removed from cart - User: ${req.user.email}, Product: ${removedItem.productName}`);\n    \n  } catch (error) {\n    console.error('Error removing item from cart:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error removing item from cart',\n      error: error.message\n    });\n  }\n});\n\n// DELETE /api/cart/clear - Clear entire cart\napp.delete('/api/cart/clear', authenticateToken, async (req, res) => {\n  try {\n    const userId = new ObjectId(req.user.userId);\n    \n    // Find cart\n    const cart = await cartCollection.findOne({ userId, status: 'active' });\n    if (!cart) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cart not found',\n        error: 'No active cart exists'\n      });\n    }\n    \n    // Clear cart\n    cart.items = [];\n    cart.totalAmount = 0;\n    cart.totalItems = 0;\n    cart.updatedAt = new Date();\n    \n    // Save cart\n    await cartCollection.replaceOne({ _id: cart._id }, cart);\n    \n    res.status(200).json({\n      success: true,\n      message: 'Cart cleared successfully',\n      cart: cart\n    });\n    \n    console.log(`âœ… Cart cleared - User: ${req.user.email}`);\n    \n  } catch (error) {\n    console.error('Error clearing cart:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error clearing cart',\n      error: error.message\n    });\n  }\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.status(200).json({ \n    status: 'OK',\n    message: 'Server is running',\n    database: db ? 'Connected' : 'Disconnected'\n  });\n});\n\n// Root endpoint\napp.get('/', (req, res) => {\n  res.json({ \n    message: 'SM Furnishing Products API',\n    endpoints: {\n      'POST /api/signup': 'User registration (name, email, password)',\n      'POST /api/login': 'User authentication (email, password)',\n      'POST /api/send-otp': 'Send OTP to email for verification (email)',\n      'POST /api/verify-otp': 'Verify OTP code (email, otp)',\n      'GET /api/products': 'Get all products',\n      'POST /api/products': 'Create new product',\n      'GET /api/products/:id': 'Get single product',\n      'DELETE /api/products/:id': 'Delete product',\n      'GET /api/latestproducts': 'Get all latest products',\n      'GET /api/latestproducts/:id': 'Get single latest product',\n      'GET /api/categories': 'Get all categories',\n      'POST /api/categories': 'Create new category',\n      'GET /api/categories/:id': 'Get single category',\n      'DELETE /api/categories/:id': 'Delete category',\n      'POST /api/form-data': 'Store form submission (name, email, phoneNumber, orderDescription)',\n      'POST /api/newsletter-emails': 'Store email subscription (email)',\n      'GET /api/cart': 'Get user\\'s cart (requires JWT token)',\n      'POST /api/cart/add': 'Add item to cart (productId, quantity) (requires JWT token)',\n      'PUT /api/cart/update': 'Update cart item quantity (productId, quantity) (requires JWT token)',\n      'DELETE /api/cart/item/:productId': 'Remove item from cart (requires JWT token)',\n      'DELETE /api/cart/clear': 'Clear entire cart (requires JWT token)',\n      'GET /health': 'Health check'\n    }\n  });\n});\n\n// Start server\nconst PORT = process.env.PORT || 3000;\n\nasync function startServer() {\n  await connectToMongoDB();\n  \n  app.listen(PORT, '0.0.0.0', () => {\n    console.log(`ðŸš€ Server is running on http://0.0.0.0:${PORT}`);\n    console.log(`ðŸ“ Products endpoint: http://0.0.0.0:${PORT}/api/products`);\n    console.log(`âž• Add product: POST http://0.0.0.0:${PORT}/api/products`);\n  });\n}\n\nstartServer();\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\nðŸ”„ Closing MongoDB connection...');\n  await client.close();\n  console.log('ðŸ‘‹ Server shutdown complete');\n  process.exit(0);\n});","size_bytes":49356},"utils/replitmail.js":{"content":"// Replit Mail utility for sending emails\n// Based on blueprint:replitmail\n\nfunction getAuthToken() {\n  const xReplitToken = process.env.REPL_IDENTITY\n    ? \"repl \" + process.env.REPL_IDENTITY\n    : process.env.WEB_REPL_RENEWAL\n      ? \"depl \" + process.env.WEB_REPL_RENEWAL\n      : null;\n\n  if (!xReplitToken) {\n    throw new Error(\n      \"No authentication token found. Please set REPL_IDENTITY or ensure you're running in Replit environment.\"\n    );\n  }\n\n  return xReplitToken;\n}\n\nasync function sendEmail(message) {\n  const authToken = getAuthToken();\n\n  const response = await fetch(\n    \"https://connectors.replit.com/api/v2/mailer/send\",\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X_REPLIT_TOKEN\": authToken,\n      },\n      body: JSON.stringify({\n        to: message.to,\n        cc: message.cc,\n        subject: message.subject,\n        text: message.text,\n        html: message.html,\n        attachments: message.attachments,\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to send email\");\n  }\n\n  return await response.json();\n}\n\nmodule.exports = { sendEmail };","size_bytes":1207},"CART_API_DOCUMENTATION.md":{"content":"# Cart API Documentation\n\n## Overview\nThis cart system allows authenticated users to manage their shopping cart with full CRUD operations. All cart endpoints require JWT authentication via the `Authorization: Bearer <token>` header.\n\n## Authentication\nGet a JWT token by calling:\n- `POST /api/signup` - Register new user\n- `POST /api/login` - Login existing user\n\nUse the returned token in all cart requests:\n```\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n```\n\n## Available Products\n- Product ID: `68cd63fefb7a3a513f2f1a8d` - DEMO1 (Price: â‚¹123, Stock: 2)\n- Product ID: `68cdb2db20a6483bbe6e9518` - Hi Akshita (Price: â‚¹12, Stock: 12)\n\n---\n\n## 1. GET /api/cart - Get User's Cart\n\n**Description:** Retrieve the user's active cart or create an empty one if it doesn't exist.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt_token>\nContent-Type: application/json\n```\n\n**Example Request:**\n```bash\ncurl -X GET http://localhost:5000/api/cart \\\n  -H \"Authorization: Bearer <your_jwt_token>\" \\\n  -H \"Content-Type: application/json\"\n```\n\n**Example Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Cart retrieved successfully\",\n  \"cart\": {\n    \"_id\": \"507f1f77bcf86cd799439011\",\n    \"userId\": \"507f1f77bcf86cd799439012\",\n    \"items\": [],\n    \"totalAmount\": 0,\n    \"totalItems\": 0,\n    \"status\": \"active\",\n    \"createdAt\": \"2025-09-21T08:30:00.000Z\",\n    \"updatedAt\": \"2025-09-21T08:30:00.000Z\"\n  }\n}\n```\n\n---\n\n## 2. POST /api/cart/add - Add Item to Cart\n\n**Description:** Add a product to the cart or increase quantity if it already exists. Validates product existence and stock availability.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt_token>\nContent-Type: application/json\n```\n\n**Request Body:**\n```json\n{\n  \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n  \"quantity\": 1\n}\n```\n\n**Example Request:**\n```bash\ncurl -X POST http://localhost:5000/api/cart/add \\\n  -H \"Authorization: Bearer <your_jwt_token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n    \"quantity\": 1\n  }'\n```\n\n**Example Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Item added to cart successfully\",\n  \"cart\": {\n    \"_id\": \"507f1f77bcf86cd799439011\",\n    \"userId\": \"507f1f77bcf86cd799439012\",\n    \"items\": [\n      {\n        \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n        \"productName\": \"DEMO1\",\n        \"productImage\": \"\",\n        \"quantity\": 1,\n        \"priceAtTime\": 123,\n        \"addedAt\": \"2025-09-21T08:30:00.000Z\"\n      }\n    ],\n    \"totalAmount\": 123,\n    \"totalItems\": 1,\n    \"status\": \"active\",\n    \"updatedAt\": \"2025-09-21T08:30:00.000Z\"\n  }\n}\n```\n\n**Error Responses:**\n- `400` - Missing productId or quantity\n- `400` - Quantity must be greater than 0\n- `404` - Product not found\n- `400` - Insufficient stock\n\n---\n\n## 3. PUT /api/cart/update - Update Item Quantity\n\n**Description:** Update the quantity of an existing cart item. Set quantity to 0 to remove the item.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt_token>\nContent-Type: application/json\n```\n\n**Request Body:**\n```json\n{\n  \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n  \"quantity\": 2\n}\n```\n\n**Example Request:**\n```bash\ncurl -X PUT http://localhost:5000/api/cart/update \\\n  -H \"Authorization: Bearer <your_jwt_token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n    \"quantity\": 2\n  }'\n```\n\n**Example Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Cart updated successfully\",\n  \"cart\": {\n    \"_id\": \"507f1f77bcf86cd799439011\",\n    \"userId\": \"507f1f77bcf86cd799439012\",\n    \"items\": [\n      {\n        \"productId\": \"68cd63fefb7a3a513f2f1a8d\",\n        \"productName\": \"DEMO1\",\n        \"productImage\": \"\",\n        \"quantity\": 2,\n        \"priceAtTime\": 123,\n        \"addedAt\": \"2025-09-21T08:30:00.000Z\"\n      }\n    ],\n    \"totalAmount\": 246,\n    \"totalItems\": 2,\n    \"status\": \"active\",\n    \"updatedAt\": \"2025-09-21T08:31:00.000Z\"\n  }\n}\n```\n\n**Error Responses:**\n- `400` - Missing productId or quantity\n- `400` - Quantity cannot be negative\n- `404` - Cart not found\n- `404` - Item not found in cart\n- `400` - Insufficient stock\n\n---\n\n## 4. DELETE /api/cart/item/:productId - Remove Single Item\n\n**Description:** Remove a specific product from the cart completely.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt_token>\nContent-Type: application/json\n```\n\n**Example Request:**\n```bash\ncurl -X DELETE http://localhost:5000/api/cart/item/68cd63fefb7a3a513f2f1a8d \\\n  -H \"Authorization: Bearer <your_jwt_token>\" \\\n  -H \"Content-Type: application/json\"\n```\n\n**Example Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Item removed from cart successfully\",\n  \"cart\": {\n    \"_id\": \"507f1f77bcf86cd799439011\",\n    \"userId\": \"507f1f77bcf86cd799439012\",\n    \"items\": [],\n    \"totalAmount\": 0,\n    \"totalItems\": 0,\n    \"status\": \"active\",\n    \"updatedAt\": \"2025-09-21T08:32:00.000Z\"\n  }\n}\n```\n\n**Error Responses:**\n- `400` - Invalid product ID format\n- `404` - Cart not found\n- `404` - Item not found in cart\n\n---\n\n## 5. DELETE /api/cart/clear - Clear Entire Cart\n\n**Description:** Remove all items from the user's cart.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt_token>\nContent-Type: application/json\n```\n\n**Example Request:**\n```bash\ncurl -X DELETE http://localhost:5000/api/cart/clear \\\n  -H \"Authorization: Bearer <your_jwt_token>\" \\\n  -H \"Content-Type: application/json\"\n```\n\n**Example Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Cart cleared successfully\",\n  \"cart\": {\n    \"_id\": \"507f1f77bcf86cd799439011\",\n    \"userId\": \"507f1f77bcf86cd799439012\",\n    \"items\": [],\n    \"totalAmount\": 0,\n    \"totalItems\": 0,\n    \"status\": \"active\",\n    \"updatedAt\": \"2025-09-21T08:33:00.000Z\"\n  }\n}\n```\n\n**Error Responses:**\n- `404` - Cart not found\n\n---\n\n## Authentication Errors\n\nAll cart endpoints may return:\n- `401` - No token provided\n- `403` - Invalid or expired token\n\n## Response Format\n\nAll responses follow this consistent format:\n```json\n{\n  \"success\": true/false,\n  \"message\": \"Success message\",\n  \"cart\": { /* full cart object */ },\n  \"error\": \"Error message if any\"\n}\n```\n\n## Base URL\n- **Development:** `http://localhost:5000`\n- **Production:** Will be provided after deployment\n\n## Notes\n- Product prices are stored in the cart when added (not live prices)\n- Stock availability is checked on add/update operations\n- Cart totals (totalAmount, totalItems) are automatically calculated\n- All cart operations are atomic and handle errors properly\n- Each user can have only one active cart at a time","size_bytes":6466}},"version":1}